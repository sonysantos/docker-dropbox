#!/bin/bash

INTERACTIVE=
NAME=dbox
BASE_DIR=dropbox-containers
DEFAULT_CMD=
ATTACH_CMD=bash
ATTACH_MODE=
RESTART_POLICY=always
FULL_PATH=
QUIET=
DEBUG=
VALID_INITIAL="a-zA-Z0-9_."
VALID_NAME="$VALID_INITIAL-"
VALID_FILENAME=" /$VALID_NAME"
ERROR_MSG=

SHORT_HELP="
Usage: $0 [options] [NAME]

NAME is the container name and the base subdirectory for dropbox
account, normally under \$HOME/BASE_DIR/. It defaults to $NAME.

Options:
  -i, --interactive        Interactive mode (default: daemon mode)
  -b, --base-dir=BASE_DIR  Parent directory for NAME under \$HOME
  --full-path=FULL_PATH    Path to be used instead of \$HOME/BASE_DIR/NAME
  -c, --command=CMD        Set alternative command for the container
  -a, --attach[=CMD]       Attach CMD (default: bash) to a running container
  --restart=RESTART_POLICY Set restart policy for daemon mode
  -h, --help               Display detailed help
  -q, --quiet              Show no info at all
  --debug                  Show additional info for debugging this script
"

LONG_HELP="Script to generate and excecute docker command to run a dropbox container.

Usage: $0 [options] [NAME]

NAME is a nickname for the Dropbox account. It is used both as the container name and as the parent directory for Dropbox subdirectories (Dropbox, .dropbox and .dropbox-dist) under BASE_DIR, that is:

BASE_DIR           # base directory; see also --base-dir option below
  +- NAME          # nickname for this Dropbox account and container
  |   +- Dropbox   # synced documents in this Dropbox account
  |   +- .dropbox  # local metadata for this Dropbox account
  +- ANOTHER_NAME  # nickname for another Dropbox account, etc.
  ...

This way you can have several different Dropbox accounts running in paralell in the same machine, each with a different name.

If omitted, NAME defaults to $NAME.

BASE_DIR is a subdirectory of \$HOME and it defaults to $BASE_DIR. You can alter it with the --base-dir option (see below).

You can also use the --full-path option to set the full path of the Dropbox account, if it is not composed by \$HOME/BASE_DIR/NAME. See details below.

Options are:

  -i, --interactive
      Run in interactive mode; useful to link dropbox account. By default it runs as a daemon, unless if Dropbox subdirectories don't exist under \$HOME/BASE_DIR/NAME. In this case they will be created.

  -b, --base-dir=BASE_DIR
      BASE_DIR is a subdirectory of \$HOME and it's a base for several dropbox accounts, each one under a different NAME under BASE_DIR. If omitted, it defaults to $BASE_DIR.

  --full-path=FULL_PATH
      If the path of the dropbox account is not of the form \$HOME/BASE_DIR/NAME, you can set the full path with this option. It must exist. If it doesn't start with a slash (/) it will be considered as a subdirectory of \$HOME. Besides it will not be followed by /NAME, NAME still will be used as the container name. This option overrides the --base-dir option above.

  -c, --command=CMD
      Override default command with CMD (e.g. bash). At this moment arguments for CMD are not supported.

  -a, --attach[=CMD]
      Attach CMD to a running container. If omitted, CMD defaults to $ATTACH_CMD in this option. This option is always interactive. Other options are ignored.

  --restart=RESTART_POLICY
      Set the restart policy for the container. Applies only to daemon mode. Default is 'always'. See docker documentation for details.

  -h, --help
      Display this message.

  -q, --quiet
      Show no info at all.

  --debug
      Show additional info for debugging this script."

# 0 argument message
[[ "$#" == "0" ]] && echo "Using default directories. Use -h or --help option for details."

# check existence of directory supplied by user
check_user_supplied_dir () {
  if [[ "$arg" != /* ]]; then
    arg="$HOME/$arg"
  fi
  if [[ ! -d "$arg" ]]; then
    echo "Path supplied via --fullpath doesn't exist: $arg" >&2
    exit 1
  fi
}

for i in "$@"; do

  # test input

  eqpos=`expr index "$i" "="`

  if [[ $eqpos > 0 ]]; then

    opt="${i:0:$eqpos}"
    arg="${i:$eqpos}"

    if [[ "$arg" =~ ^[$VALID_INITIAL][$VALID_NAME]*$ ]]; then
      opt+="NAME"

    elif [[ "$arg" =~ ^/?[$VALID_INITIAL][$VALID_FILENAME]*$ ]]; then
      opt+="FILENAME"
      arg=$(sed 's:/\+$::' <<<$arg)      # remove last bars

    else
      opt+="OTHER_ARGUMENT"
    fi

    [[ "$opt" == *NAME && ( "$arg" == *..* || "$arg" == *//* ) ]] && \
      opt="INVALID_FILENAME"

  elif [[ "$i" == -* ]]; then
    opt=$i
    arg=
  elif [[ "$i" =~ ^[$VALID_INITIAL][$VALID_NAME]*$ ]]; then
    opt="NAME"
    arg=$i
  else
    opt="INVALID_NAME"
    arg=$i
  fi

  [[ -n "$DEBUG" ]] && echo "Option: $opt ($arg)"

  case $opt in

    -i|--interactive)
    INTERACTIVE=1
    ;;

    -b=*NAME|--base-dir=*NAME)
    BASE_DIR=${arg#/}             # remove eventual first bar
    ;;

    --full-path=*NAME)
    check_user_supplied_dir
    FULL_PATH=$arg
    ;;

    -c=*NAME|--command=*NAME)
    DEFAULT_CMD=$arg
    ;;

    -a|--attach)
    ATTACH_MODE=1
    ;;

    -a=*NAME|--attach=*NAME)
    ATTACH_MODE=1
    ATTACH_CMD=$arg
    ;;

    --restart=*)
    if [[ "$arg" =~ ^(always|no|unless-stopped|on-failure(:[0-9]+)?)$ ]]; then
      RESTART_POLICY=$arg
    else
      ERROR_MSG="Invalid restart policy: $arg"
    fi
    ;;

    -h|--help)
    # help | add blank lines | format | remove added blank lines
    echo "$LONG_HELP" | sed G | fmt -c | sed -e '$d' -e '/^$/ N; s/\n//'
    exit 0
    ;;

    -q|--quiet)
    QUIET=1
    ;;

    --debug)
    DEBUG=1
    ;;

    NAME)
    NAME=$arg
    ;;

    INVALID_NAME)
    ERROR_MSG="Invalid name: $arg"
    ;;

    INVALID_FILENAME)
    ERROR_MSG="Name and path cannot contain two adjacent dots or slashes: $arg"
    ;;

    -*=OTHER_ARGUMENT)
    ERROR_MSG="Invalid argument: $arg"
    ;;

    -*)
    ERROR_MSG="Invalid option: $opt"
    ;;

    *)
    ERROR_MSG="Unknown error for option $opt and argument $arg"
    ;;

  esac

  # check for errors
  if [[ -n "$ERROR_MSG" ]]; then
    echo "$ERROR_MSG" >&2
    echo "$SHORT_HELP"
    exit 1
  fi

  shift

done

check_create_dir () {
  if [[ ! -d "$1" ]]; then
    [[ -z "$QUIET" ]] && echo "Creating directory '$1'..."
    mkdir $2 "$1" || {
      echo "Could not create $1" >&2
      exit 1
    }
  fi
}

# set fullpath
if [[ -z $FULL_PATH ]]; then
  FULL_PATH=$HOME/$BASE_DIR/$NAME
  check_create_dir "$FULL_PATH" -p
fi

# test existence of Dropbox and .dropbox directories
check_dbox_dirs () {
  local dirname="$FULL_PATH/$1"
  check_create_dir "$dirname"
}

check_dbox_dirs Dropbox
check_dbox_dirs .dropbox
check_dbox_dirs .dropbox-dist

# if dropbox is empty set INTERACTIVE mode
[[ ! "$(ls -A $FULL_PATH/.dropbox)" ]] && INTERACTIVE=1

# attach mode
if [[ -n "$ATTACH_MODE" ]]; then
  DOCKER_CMD="docker exec -it $NAME $ATTACH_CMD"
else

  if [[ -n "$INTERACTIVE" ]]; then
    DOCKER_OPT="-it --rm"
  else
    DOCKER_OPT="-d --restart=$RESTART_POLICY"
  fi

  VOLUMES=" \\
    -v $FULL_PATH/Dropbox:/dbox/Dropbox \\
    -v $FULL_PATH/.dropbox:/dbox/.dropbox \\
    -v $FULL_PATH/.dropbox-dist:/dbox/.dropbox-dist"

  ENV_DBOX=" \\
    -e DBOX_UID=`id -u` \\
    -e DBOX_GID=`id -g` \\
  "

  IMAGE="sonysantos/dropbox:latest"

  DOCKER_CMD="docker run $DOCKER_OPT --name $NAME $VOLUMES $ENV_DBOX $IMAGE $DEFAULT_CMD"
fi

[[ -z "$QUIET" || -n "$DEBUG" ]] && \
  echo -e "\nGenerated Docker command:\n$DOCKER_CMD"

[[ -z "$DEBUG" ]] && {
  [[ -z "$QUIET" ]] && echo -e "\nExecuting Docker Command..."
  `$DOCKER_CMD`
}
