#!/bin/bash

INTERACTIVE=
NAME=dbox
BASE_DIR=dropbox-containers
DEFAULT_CMD=
ATTACH_CMD=bash
ATTACH_MODE=
RESTART_POLICY=always
FULL_PATH=
VERBOSE=
VALID_INITIAL="a-zA-Z0-9_."
VALID_NAME="$VALID_INITIAL-"
VALID_FILENAME=" /$VALID_NAME"
ERROR_MSG=

SHORT_HELP="
Usage: $0 [options] [NAME]

NAME is the container name and the base subdirectory for dropbox
account, normally under \$HOME. It defaults to $NAME.

Options:
  -i, --interactive        Interactive mode (default: daemon mode)
  -b, --base-dir=BASE_DIR  Parent directory for NAME (default \$HOME)
  --full-path=FULL_PATH    Path to be used instead of BASE_DIR/NAME
  -c, --command=CMD        Set alternative command for the container
  -a, --attach[=CMD]       Attach CMD (default: bash) to a running container
  --restart=RESTART_POLICY Set restart policy for daemon mode
  -h, --help               Display detailed help
  -v, --verbose            Show info about the docker command
"

LONG_HELP="Usage: $0 [options] [NAME]

NAME is a nickname for the Dropbox account. It is used both as the
container name and as the parent directory for Dropbox subdirectories
(Dropbox, .dropbox and .dropbox-dist) under BASE_DIR, that is:

BASE_DIR             # base directory; see also --base-dir option below
  +- NAME            # nickname for this Dropbox account and container
  |   +- Dropbox     # synced documents in this Dropbox account
  |   +- .dropbox    # local metadata for this Dropbox account
  +- ANOTHER_NAME    # nickname for another Dropbox account, etc.
  ...

This way you can have several different Dropbox accounts running in
paralell in the same machine, each with a different name.

If omitted, NAME defaults to $NAME.

BASE_DIR is a subdirectory of \$HOME and it defaults to $BASE_DIR.
You can alter it with the --base-dir option (see below).

You can also use the --full-path option to set the full path of the
Dropbox account, if it is not composed by \$HOME/BASE_DIR/NAME.
See details below.

Options are:

  -i, --interactive
      Run in interactive mode; useful to link dropbox account. By
      default it runs as a daemon, unless if Dropbox subdirectories
      don't exist under \$HOME/BASE_DIR/NAME. In this case they will be
      created.

  -b, --base-dir=BASE_DIR
      BASE_DIR is a subdirectory of \$HOME and it's a base for several
      dropbox accounts, each one under a different NAME under BASE_DIR.
      If omitted, it defaults to $BASE_DIR.

  --full-path=FULL_PATH
      If the path of the dropbox account is not of the form
      \$HOME/BASE_DIR/NAME, you can set the full path with this option.
      It must exist. If it doesn't start with a slash (/) it will be
      considered as a subdirectory of \$HOME. Besides it will not be
      followed by /NAME; NAME still will be used as the container name.
      This option overrides the --base-dir option above.

  -c, --command=CMD
      Override default command with CMD (e.g. bash). At this moment
      arguments are not supported.

  -a, --attach[=CMD]
      Attach CMD to a running container. If omitted, CMD defaults
      to $ATTACH_CMD in this option. This option is always
      interactive. Other options are ignored

  --restart=RESTART_POLICY
      Set the restart policy for the container. Applies only to
      daemon mode. Default is 'always'. See docker documentation
      for details.

  -h, --help
      Display this message.

  -v, --verbose
      Show info about the docker command.
"

if [[ "$#" == "0" ]]; then
  echo "$SHORT_HELP"
  exit 0
fi

# check existence of directory supplied by user
check_user_supplied_dir () {
  if [[ "$arg" != /* ]]; then
    arg="$HOME/$arg"
  fi
  if [[ ! -d "$arg" ]]; then
    echo "Path supplied via --fullpath doesn't exist: $arg" >&2
    exit 1
  fi
}

for i in "$@"; do

  # test input

  eqpos=`expr index "$i" "="`

  if [[ $eqpos > 0 ]]; then
    opt="${i:0:$eqpos}"
    arg="${i:$eqpos}"
    if [[ "$arg" =~ ^[$VALID_INITIAL][$VALID_NAME]*$ ]]; then
      opt+="NAME"
    elif [[ "$arg" =~ ^/?[$VALID_INITIAL][$VALID_FILENAME]*$ ]]; then
      opt+="FILENAME"
      # remove last bars (#so better way?)
      while [[ "$arg" == */ ]]; do arg=${arg%/}; done
    else
      opt+="OTHER_ARGUMENT"
    fi
    if [[ "$opt" == *NAME && "$arg" == *..* || "$arg" == "//" ]]; then
      opt="INVALID_FILENAME"
    fi
  elif [[ "$i" == -* ]]; then
    opt=$i
    arg=
  elif [[ "$i" =~ ^[$VALID_INITIAL][$VALID_NAME]*$ ]]; then
    opt="NAME"
    arg=$i
  else
    opt="INVALID_NAME"
    arg=$i
  fi

  [[ -n "$VERBOSE" ]] && echo "Option: $opt ($arg)"

  case $opt in

    -i|--interactive)
    INTERACTIVE=1
    ;;

    -b=*NAME|--base-dir=*NAME)
    BASE_DIR=${arg#/}             # remove eventual first bar
    ;;

    --full-path=FILENAME)
    check_user_supplied_dir
    FULL_PATH=$arg
    ;;

    -c=FILENAME|--command=FILENAME)
    DEFAULT_CMD=$arg
    ;;

    -a|--attach)
    ATTACH_MODE=1
    ;;

    -a=FILENAME|--attach=FILENAME)
    ATTACH_MODE=1
    ATTACH_CMD=$arg
    ;;

    --restart=*)
    if [[ "$arg" =~ ^(always|no|unless-stopped|on-failure(:[0-9]+)?)$ ]]; then
      RESTART_POLICY=$arg
    else
      ERROR_MSG="Invalid restart policy: $arg"
    fi
    ;;

    -h|--help)
    echo "$LONG_HELP"
    exit 0
    ;;

    -v|--verbose)
    VERBOSE=1
    ;;

    NAME)
    NAME=$arg
    ;;

    INVALID_NAME)
    ERROR_MSG="Invalid name: $arg"
    ;;

    INVALID_FILENAME)
    ERROR_MSG="Name and path cannot contain two adjacent dots (..): $arg"
    ;;

    -*=OTHER_ARGUMENT)
    ERROR_MSG="Invalid argument: $arg"
    ;;

    -*)
    ERROR_MSG="Invalid option: $opt"
    ;;

    *)
    ERROR_MSG="Unknown error for option $opt and argument $arg"
    ;;

  esac

  # check for errors
  if [[ -n "$ERROR_MSG" ]]; then
    echo "$ERROR_MSG" >&2
    echo "$SHORT_HELP"
    exit 1
  fi

  shift

done

check_create_dir () {
  if [[ ! -d "$1" ]]; then
    [[ -n "$VERBOSE" ]] && echo "Creating directory '$1'..."
    mkdir "$1" || {
      echo "Could not create $1" >&2
      exit 1
    }
  fi
}

# set fullpath
if [[ -z $FULL_PATH ]]; then
  FULL_PATH=$HOME/$BASE_DIR/$NAME
  check_create_dir "$FULL_PATH"
fi

# test existence of Dropbox and .dropbox directories
check_dbox_dirs () {
  local dirname="$FULL_PATH/$1"
  check_create_dir "$dirname"
}

check_dbox_dirs Dropbox
check_dbox_dirs .dropbox
check_dbox_dirs .dropbox-dist

# if dropbox is empty set INTERACTIVE mode
if [ ! "$(ls -A $FULL_PATH/.dropbox)" ]
  INTERACTIVE=1
fi

# attach mode
if [[ -n "$ATTACH_MODE" ]]; then
  DOCKER_CMD="docker exec -it $NAME $ATTACH_CMD"
else

  if [[ -n "$INTERACTIVE" ]]; then
    DOCKER_OPT="-it --rm"
  else
    DOCKER_OPT="-d --restart=$RESTART_POLICY"
  fi

  VOLUMES="
    -v $FULL_PATH/Dropbox:/dbox/Dropbox
    -v $FULL_PATH/.dropbox:/dbox/.dropbox
    -v $FULL_PATH/.dropbox-dist:/dbox/.dropbox-dist"

  ENV_DBOX="
    -e DBOX_UID=`id -u`
    -e DBOX_GID=`id -g`
  "

  IMAGE="sonysantos/dropbox:latest"

  DOCKER_CMD="docker run $DOCKER_OPT --name $NAME $VOLUMES $ENV_DBOX $IMAGE $DEFAULT_CMD"
fi

[[ -n "$VERBOSE" ]] && echo -e "\n$DOCKER_CMD"
